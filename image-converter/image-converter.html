<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Converter & Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* Custom styles to ensure "Inter" font and rounded corners */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to start to prevent extreme vertical centering issues on small screens */
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 95%; /* Responsive width */
            width: 1200px; /* Max width for desktop */
            background-color: #ffffff;
            padding: 32px;
            border-radius: 16px; /* Rounded corners for the main container */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 24px; /* Space between sections */
        }
        .drop-zone {
            border: 4px dashed #9ca3af;
            padding: 40px;
            text-align: center;
            font-size: 1.5rem;
            color: #6b7280;
            background-color: #f9fafb;
            border-radius: 12px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #e0f2fe;
            color: #1d4ed8;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Responsive grid */
            gap: 24px;
        }
        .image-card {
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .image-card canvas {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
        }
        .image-card button,
        .image-card select,
        .image-card input[type="number"] {
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            background-color: #ffffff;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        /* Global buttons */
        .global-controls button,
        #convertAllBtn {
            background-color: #3b82f6;
            color: white;
            font-weight: 600;
            border: none;
            padding: 12px 20px; /* Larger padding for global buttons */
            font-size: 1.125rem; /* Larger font size */
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .global-controls button:hover,
        #convertAllBtn:hover {
            background-color: #2563eb;
        }

        #exportZipBtn {
            background-color: #10b981; /* Green for export zip button */
        }
        #exportZipBtn:hover {
            background-color: #059669;
        }

        .image-card .remove-btn {
            background-color: #ef4444; /* Red for remove button */
        }
        .image-card .remove-btn:hover {
            background-color: #dc2626;
        }
        input[type="number"][disabled],
        input[type="checkbox"][disabled] + label,
        select[disabled] { /* Added select[disabled] */
            background-color: #e5e7eb;
            cursor: not-allowed;
            color: #9ca3af;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #d1d5db;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            transition: background 0.15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            transition: background 0.15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb:active {
            cursor: grabbing;
        }
        .message-box {
            padding: 12px;
            border-radius: 8px;
            border: 1px solid;
            display: none;
            margin-top: 10px;
        }
        .message-box.error {
            background-color: #fee2e2;
            color: #ef4444;
            border-color: #fca5a5;
        }
        .message-box.info {
            background-color: #e0f2fe;
            color: #0c6a9b;
            border-color: #7dd3fc;
        }
        /* Hide default file input button */
        #hiddenFileInput {
            display: none;
        }
        .global-controls > div {
            background-color: #f9fafb; /* Lighter background for control groups */
            padding: 16px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .global-controls input[type="number"] {
            cursor: text; /* Allow normal text cursor for number inputs */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 rounded-lg p-2">Multi-File Converter & Exporter</h1>

        <div id="dropZone" class="drop-zone">
            Drag & Drop Files or Folders Here or Click to Upload
        </div>
        <input type="file" id="hiddenFileInput" multiple webkitdirectory directory>

        <div id="loadingBarContainer" class="hidden w-full bg-gray-200 rounded-full h-4 mt-4 relative">
            <div id="loadingBar" class="bg-blue-600 h-4 rounded-full transition-all duration-100 ease-out" style="width: 0%;"></div>
            <div id="loadingText" class="absolute inset-0 flex items-center justify-center text-xs font-semibold text-white">0%</div>
        </div>

        <div id="generalMessageBox" class="message-box hidden rounded-lg"></div>

        <div class="global-controls flex flex-col gap-6">
            <h2 class="text-2xl font-bold text-gray-800">Global Image Adjustments</h2>

            <div>
                <label class="text-lg font-medium text-gray-700 mb-2 block">Upload Options:</label>
                <div class="flex items-center gap-4">
                    <input type="checkbox" id="disablePreviewsCheckbox" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                    <label for="disablePreviewsCheckbox" class="text-gray-700">Disable Image Previews when Uploading</label>
                </div>
            </div>

            <div>
                <label class="text-lg font-medium text-gray-700 mb-2 block">Visual Adjustments (Images Only):</label>
                <div class="flex items-center gap-4">
                    <input type="checkbox" id="globalInvertColors" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="globalInvertColors" class="text-gray-700">Invert Colors</label>
                </div>
                <div class="flex flex-col gap-2 mt-4">
                    <label for="globalSaturation" class="text-gray-700">Saturation: <span id="globalSaturationValue">100</span>%</label>
                    <input type="range" id="globalSaturation" min="0" max="200" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <div>
                <label class="text-lg font-medium text-gray-700 mb-2 block">Scaling Options (Images Only):</label>
                <div class="flex items-center gap-4">
                    <input type="checkbox" id="globalEnableScaling" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="globalEnableScaling" class="text-gray-700">Enable Scaling</label>
                </div>
                <div class="flex flex-col md:flex-row gap-4 mt-4">
                    <div class="flex flex-col flex-1">
                        <label for="globalScaleWidth" class="text-gray-700 mb-1">Width (px):</label>
                        <input type="number" id="globalScaleWidth" min="1" placeholder="Original Width" class="p-2 border rounded-md" disabled>
                    </div>
                    <div class="flex flex-col flex-1">
                        <label for="globalScaleHeight" class="text-gray-700 mb-1">Height (px):</label>
                        <input type="number" id="globalScaleHeight" min="1" placeholder="Original Height" class="p-2 border rounded-md" disabled>
                    </div>
                </div>
                <div class="flex items-center gap-4 mt-4">
                    <input type="checkbox" id="globalMaintainAspectRatio" class="form-checkbox h-5 w-5 text-blue-600 rounded" disabled>
                    <label for="globalMaintainAspectRatio" class="text-gray-700">Maintain Aspect Ratio</label>
                </div>
            </div>

            <div>
                <label for="globalOutputFormat" class="text-lg font-medium text-gray-700 mb-2 block">Convert To (Images Only):</label>
                <select id="globalOutputFormat" class="rounded-lg p-2 w-full">
                    <option value="image/png">PNG (Lossless)</option>
                    <option value="image/jpeg">JPG (Highest Quality)</option>
                    <option value="image/webp">WEBP (Highest Quality)</option>
                    <option value="image/avif">AVIF (Limited Browser Support)</option>
                    <option value="image/tiff">TIFF (Limited Browser Support)</option>
                </select>
                <div class="flex items-center gap-2 mt-4">
                    <input type="checkbox" id="keepOriginalTypeCheckbox" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="keepOriginalTypeCheckbox" class="text-gray-700">Keep Original File Type (for Export All Images)</label>
                </div>
            </div>

            <button id="convertAllBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-200 ease-in-out">
                Convert All Images & Download
            </button>
            <button id="exportZipBtn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-200 ease-in-out">
                Export All Files as Zip
            </button>
        </div>


        <div id="imageGrid" class="image-grid">
            </div>

        <p class="text-sm text-gray-600 mt-2 rounded-lg p-2 bg-blue-50">
            <strong>Note:</strong> This tool can process various file types.
            <br>
            For <strong>image files</strong> (PNG, JPG, WEBP), visual adjustments and scaling can be applied. If "Keep Original File Type" is selected for ZIP export, these images will retain their format after adjustments. AVIF and TIFF images are supported for input and can be included in the ZIP, but visual adjustments cannot be applied to them via browser canvas; they will be exported as their original raw files (without adjustments) when "Keep Original File Type" is enabled, or if selected as the target conversion format.
            <br>
            <strong>Non-image files</strong> will always be included in the ZIP archive in their original form without any processing or conversion.
        </p>
    </div>

    <script>
        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const hiddenFileInput = document.getElementById('hiddenFileInput');
        const imageGrid = document.getElementById('imageGrid');
        const generalMessageBox = document.getElementById('generalMessageBox');

        // New elements for loading bar and preview control
        const disablePreviewsCheckbox = document.getElementById('disablePreviewsCheckbox');
        const loadingBarContainer = document.getElementById('loadingBarContainer');
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');

        // Global adjustment elements
        const globalInvertColorsCheckbox = document.getElementById('globalInvertColors');
        const globalSaturationSlider = document.getElementById('globalSaturation');
        const globalSaturationValueSpan = document.getElementById('globalSaturationValue');
        const globalEnableScalingCheckbox = document.getElementById('globalEnableScaling');
        const globalScaleWidthInput = document.getElementById('globalScaleWidth');
        const globalScaleHeightInput = document.getElementById('globalScaleHeight');
        const globalMaintainAspectRatioCheckbox = document.getElementById('globalMaintainAspectRatio');
        const globalOutputFormatSelect = document.getElementById('globalOutputFormat');
        const keepOriginalTypeCheckbox = document.getElementById('keepOriginalTypeCheckbox');
        const convertAllBtn = document.getElementById('convertAllBtn');
        const exportZipBtn = document.getElementById('exportZipBtn');

        // Map to store state for each file, keyed by a unique ID
        const imageStates = new Map();

        // Global state for adjustments and scaling
        const globalSettings = {
            invertColors: false,
            saturation: 100,
            enableScaling: false,
            scaleWidth: null,
            scaleHeight: null,
            maintainAspectRatio: false,
            outputFormat: 'image/png',
            keepOriginalType: false,
            displayPreviews: false // New setting, default to false (meaning previews are disabled by default)
        };

        // Counters for loading progress
        let totalFilesToLoad = 0;
        let filesLoadedCount = 0;

        // Utility to generate unique IDs
        const generateUniqueId = () => `file-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

        // Function to display general messages
        function showGeneralMessage(message, type) {
            generalMessageBox.textContent = message;
            generalMessageBox.className = `message-box ${type} block`;
        }

        // Function to update loading bar progress
        function updateLoadingProgress() {
            if (totalFilesToLoad === 0) {
                loadingBarContainer.classList.add('hidden');
                return;
            }
            const progress = (filesLoadedCount / totalFilesToLoad) * 100;
            loadingBar.style.width = `${progress}%`;
            loadingText.textContent = `${Math.round(progress)}%`;

            if (filesLoadedCount === totalFilesToLoad) {
                // Delay hiding for a smoother transition and to ensure "All files loaded" message is seen
                setTimeout(() => {
                    loadingBarContainer.classList.add('hidden');
                    showGeneralMessage('All files loaded.', 'info');
                }, 500);
            }
        }

        // Function to draw an image onto its canvas with applied global filters and scaling
        function drawImageWithFiltersAndScale(cardId) {
            const fileState = imageStates.get(cardId);
            if (!fileState || !fileState.isImage || !fileState.originalImage || !fileState.canvas || !fileState.ctx) {
                return; // Only draw if it's an image and image data is loaded and has a canvas
            }

            const { originalImage, canvas, ctx } = fileState;
            const { invertColors, saturation, enableScaling, scaleWidth, scaleHeight, maintainAspectRatio } = globalSettings;

            let finalWidth = originalImage.width;
            let finalHeight = originalImage.height;

            // Scaling logic
            if (enableScaling) {
                let inputWidth = parseInt(scaleWidth);
                let inputHeight = parseInt(scaleHeight);

                const isValidWidth = !isNaN(inputWidth) && inputWidth > 0;
                const isValidHeight = !isNaN(inputHeight) && inputHeight > 0;

                const originalAspectRatio = originalImage.width / originalImage.height;

                if (maintainAspectRatio) {
                    if (isValidWidth && !isValidHeight) {
                        finalWidth = inputWidth;
                        finalHeight = Math.round(inputWidth / originalAspectRatio);
                    } else if (!isValidWidth && isValidHeight) {
                        finalHeight = inputHeight;
                        finalWidth = Math.round(inputHeight * originalAspectRatio);
                    } else if (isValidWidth && isValidHeight) {
                        const ratioW = inputWidth / originalImage.width;
                        const ratioH = inputHeight / originalImage.height;
                        const ratio = Math.min(ratioW, ratioH);
                        finalWidth = Math.round(originalImage.width * ratio);
                        finalHeight = Math.round(originalImage.height * ratio);
                    } else {
                         // No valid dimensions for aspect ratio scaling, use original
                         finalWidth = originalImage.width;
                         finalHeight = originalImage.height;
                    }
                } else {
                    if (isValidWidth) {
                        finalWidth = inputWidth;
                    }
                    if (isValidHeight) {
                        finalHeight = inputHeight;
                    }
                }
            }

            // Set canvas dimensions
            canvas.width = finalWidth;
            canvas.height = finalHeight;

            // Apply filters to the canvas context
            let filterString = '';
            if (invertColors) {
                filterString += 'invert(100%) ';
            }
            filterString += `saturate(${saturation}%)`;
            ctx.filter = filterString.trim();

            // Clear canvas and draw image
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before drawing
            ctx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

            // Reset filter to avoid affecting subsequent draws of other images if this context is reused (important for future potential features)
            ctx.filter = 'none';
        }

        // Function to update all image previews based on global settings
        function updateAllPreviews() {
            imageStates.forEach((fileState, key) => {
                if (fileState.isImage) { // Only update if it's an image
                    drawImageWithFiltersAndScale(key);
                }
            });
        }

        // Function to toggle disabled state of global scaling inputs
        function toggleGlobalScalingInputs() {
            const isDisabled = !globalSettings.enableScaling;
            globalScaleWidthInput.disabled = isDisabled;
            globalScaleHeightInput.disabled = isDisabled;
            globalMaintainAspectRatioCheckbox.disabled = isDisabled;

            if (isDisabled) {
                globalScaleWidthInput.value = '';
                globalScaleHeightInput.value = '';
                globalMaintainAspectRatioCheckbox.checked = false;
                globalSettings.scaleWidth = null;
                globalSettings.scaleHeight = null;
                globalSettings.maintainAspectRatio = false;
            } else {
                // Set placeholders to original dimensions of the first *image* if available
                let firstImageState = null;
                for (const fileState of imageStates.values()) {
                    if (fileState.isImage && fileState.originalImage) {
                        firstImageState = fileState;
                        break;
                    }
                }

                if (firstImageState) {
                    globalScaleWidthInput.placeholder = `Original: ${firstImageState.originalImage.width}px`;
                    globalScaleHeightInput.placeholder = `Original: ${firstImageState.originalImage.height}px`;
                    globalSettings.scaleWidth = firstImageState.originalImage.width;
                    globalSettings.scaleHeight = firstImageState.originalImage.height;
                } else {
                    globalScaleWidthInput.placeholder = `Original Width`;
                    globalScaleHeightInput.placeholder = `Original Height`;
                }
            }
            updateAllPreviews(); // Update previews based on the new scaling state
        }


        // Function to create and append a file card to the grid
        function addOrUpdateFileCard(cardId, file, originalImage, relativePath, isImage, statusMessage = '') {
            const existingCard = document.getElementById(`card-${cardId}`);
            if (existingCard) {
                existingCard.remove(); // Remove existing card if re-adding
            }

            const displayName = relativePath && relativePath.length > 0 ? relativePath : file.name;

            let cardContentHtml;
            let canvas = null;
            let ctx = null;

            if (isImage && originalImage) { // Only create canvas if it's an image AND originalImage is loaded
                cardContentHtml = `
                    <canvas id="canvas-${cardId}" class="w-full h-auto rounded-lg shadow-md"></canvas>
                `;
            } else {
                cardContentHtml = `
                    <div class="p-4 bg-gray-100 rounded-lg text-gray-700 text-sm">
                        <p><strong>Type:</strong> ${file.type || 'Unknown'}</p>
                        <p><strong>Size:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
                        ${statusMessage ? `<p class="text-red-500">${statusMessage}</p>` : ''}
                    </div>
                `;
            }

            const cardHtml = `
                <div id="card-${cardId}" class="image-card">
                    <h3 class="text-xl font-semibold text-gray-800 break-words">${displayName}</h3>
                    ${cardContentHtml}
                    <button id="removeBtn-${cardId}" class="remove-btn bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                        Remove File
                    </button>
                </div>
            `;
            imageGrid.insertAdjacentHTML('beforeend', cardHtml);

            if (isImage && originalImage) {
                canvas = document.getElementById(`canvas-${cardId}`);
                ctx = canvas.getContext('2d');
            }
            const removeBtn = document.getElementById(`removeBtn-${cardId}`);

            imageStates.set(cardId, {
                file: file,
                originalImage: originalImage, // Will be null if previews disabled or non-image
                canvas: canvas, // Will be null if previews disabled or non-image
                ctx: ctx, // Will be null if previews disabled or non-image
                relativePath: relativePath,
                isImage: isImage // True if detected as image type, regardless of preview status
            });

            // If it's an image AND originalImage is loaded (i.e., previews enabled and loaded successfully), perform initial draw
            if (isImage && originalImage) {
                drawImageWithFiltersAndScale(cardId);
            }

            // Add Event Listeners for this card's elements
            removeBtn.addEventListener('click', () => {
                imageStates.delete(cardId);
                document.getElementById(`card-${cardId}`).remove();
                showGeneralMessage(`Removed "${displayName}".`, 'info');
            });
        }

        // Handle files from drag-and-drop or file input
        function handleFiles(files) {
            showGeneralMessage('', ''); // Clear general messages
            imageGrid.innerHTML = ''; // Clear existing files when new ones are loaded

            totalFilesToLoad = 0;
            filesLoadedCount = 0;
            imageStates.clear(); // Clear existing image states

            const filesArray = Array.from(files).filter(file => {
                // Filter out directories (folders themselves, not their contents)
                return !(file.type === '' && file.size === 0 && file.webkitRelativePath.endsWith('/'));
            });

            totalFilesToLoad = filesArray.length;
            if (totalFilesToLoad === 0) {
                showGeneralMessage('No files found to load.', 'info');
                return;
            }

            loadingBarContainer.classList.remove('hidden');
            updateLoadingProgress(); // Initialize loading bar

            filesArray.forEach(file => {
                const relativePath = file.webkitRelativePath || '';
                const cardId = generateUniqueId();
                const displayName = relativePath && relativePath.length > 0 ? relativePath : file.name;

                const imageMimeTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/avif', 'image/tiff'];
                const isSupportedImageType = imageMimeTypes.includes(file.type);

                if (isSupportedImageType && globalSettings.displayPreviews) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            addOrUpdateFileCard(cardId, file, img, relativePath, true);
                            filesLoadedCount++;
                            updateLoadingProgress();
                            // showGeneralMessage(`Loaded image "${displayName}".`, 'info'); // Commented out to reduce message spam
                        };
                        img.onerror = function() {
                            showGeneralMessage(`Error loading image "${displayName}". It might be corrupted or an unsupported image format for display. Adding as non-previewable file.`, 'error');
                            addOrUpdateFileCard(cardId, file, null, relativePath, false, `(Image preview failed)`); // Mark as not image for preview, but retain original type
                            filesLoadedCount++;
                            updateLoadingProgress();
                        };
                        img.src = e.target.result;
                    };
                    reader.onerror = function() {
                        showGeneralMessage(`Error reading file "${displayName}". Adding as non-previewable file.`, 'error');
                        addOrUpdateFileCard(cardId, file, null, relativePath, false, `(File read failed)`); // Mark as not image for preview, but retain original type
                        filesLoadedCount++;
                        updateLoadingProgress();
                    };
                    reader.readAsDataURL(file);
                } else {
                    // This is a non-image file, or previews are disabled
                    // isImage parameter indicates if the file *is* an image type, even if we're not showing a preview
                    addOrUpdateFileCard(cardId, file, null, relativePath, isSupportedImageType, `(No preview: ${globalSettings.displayPreviews ? 'Non-image' : 'Previews disabled'})`);
                    filesLoadedCount++;
                    updateLoadingProgress();
                    // showGeneralMessage(`Loaded ${isSupportedImageType ? 'image' : 'non-image'} file "${displayName}" without preview.`, 'info'); // Commented out to reduce message spam
                }
            });
        }

        // Global Event Listeners for adjustments
        globalInvertColorsCheckbox.addEventListener('change', () => {
            globalSettings.invertColors = globalInvertColorsCheckbox.checked;
            updateAllPreviews();
        });

        globalSaturationSlider.addEventListener('input', () => {
            globalSettings.saturation = parseInt(globalSaturationSlider.value);
            globalSaturationValueSpan.textContent = globalSettings.saturation;
            updateAllPreviews();
        });

        globalEnableScalingCheckbox.addEventListener('change', () => {
            globalSettings.enableScaling = globalEnableScalingCheckbox.checked;
            toggleGlobalScalingInputs();
        });

        globalScaleWidthInput.addEventListener('input', () => {
            globalSettings.scaleWidth = globalScaleWidthInput.value;
            if (globalSettings.maintainAspectRatio && globalScaleWidthInput.value) {
                // Get original dimensions from the first image for aspect ratio calculation
                let firstImageState = null;
                for (const fileState of imageStates.values()) {
                    if (fileState.isImage && fileState.originalImage) {
                        firstImageState = fileState;
                        break;
                    }
                }
                if (firstImageState && firstImageState.originalImage) {
                    const originalAspectRatio = firstImageState.originalImage.width / firstImageState.originalImage.height;
                    const newHeight = Math.round(parseInt(globalScaleWidthInput.value) / originalAspectRatio);
                    if (!isNaN(newHeight)) {
                        globalScaleHeightInput.value = newHeight;
                        globalSettings.scaleHeight = newHeight;
                    }
                }
            }
            updateAllPreviews();
        });

        globalScaleHeightInput.addEventListener('input', () => {
            globalSettings.scaleHeight = globalScaleHeightInput.value;
            if (globalSettings.maintainAspectRatio && globalScaleHeightInput.value) {
                // Get original dimensions from the first image for aspect ratio calculation
                let firstImageState = null;
                for (const fileState of imageStates.values()) {
                    if (fileState.isImage && fileState.originalImage) {
                        firstImageState = fileState;
                        break;
                    }
                }
                if (firstImageState && firstImageState.originalImage) {
                    const originalAspectRatio = firstImageState.originalImage.width / firstImageState.originalImage.height;
                    const newWidth = Math.round(parseInt(globalScaleHeightInput.value) * originalAspectRatio);
                    if (!isNaN(newWidth)) {
                        globalScaleWidthInput.value = newWidth;
                        globalSettings.scaleWidth = newWidth;
                    }
                }
            }
            updateAllPreviews();
        });

        globalMaintainAspectRatioCheckbox.addEventListener('change', () => {
            globalSettings.maintainAspectRatio = globalMaintainAspectRatioCheckbox.checked;
            // If aspect ratio is now maintained, update the other dimension if one is set
            if (globalSettings.maintainAspectRatio) {
                let firstImageState = null;
                for (const fileState of imageStates.values()) {
                    if (fileState.isImage && fileState.originalImage) {
                        firstImageState = fileState;
                        break;
                    }
                }
                if (firstImageState && firstImageState.originalImage) {
                    const originalAspectRatio = firstImageState.originalImage.width / firstImageState.originalImage.height;
                    if (globalScaleWidthInput.value && !globalScaleHeightInput.value) {
                         const newHeight = Math.round(parseInt(globalScaleWidthInput.value) / originalAspectRatio);
                         if (!isNaN(newHeight)) {
                            globalScaleHeightInput.value = newHeight;
                            globalSettings.scaleHeight = newHeight;
                         }
                    } else if (globalScaleHeightInput.value && !globalScaleWidthInput.value) {
                        const newWidth = Math.round(parseInt(globalScaleHeightInput.value) * originalAspectRatio);
                        if (!isNaN(newWidth)) {
                            globalScaleWidthInput.value = newWidth;
                            globalSettings.scaleWidth = newWidth;
                        }
                    } else if (globalScaleWidthInput.value && globalScaleHeightInput.value) {
                        // Re-calculate to fit within bounding box if both are set
                        const inputWidth = parseInt(globalScaleWidthInput.value);
                        const inputHeight = parseInt(globalScaleHeightInput.value);
                        const ratioW = inputWidth / firstImageState.originalImage.width;
                        const ratioH = inputHeight / firstImageState.originalImage.height;
                        const ratio = Math.min(ratioW, ratioH);
                        const finalWidth = Math.round(firstImageState.originalImage.width * ratio);
                        const finalHeight = Math.round(firstImageState.originalImage.height * ratio);
                        globalScaleWidthInput.value = finalWidth;
                        globalScaleHeightInput.value = finalHeight;
                        globalSettings.scaleWidth = finalWidth;
                        globalSettings.scaleHeight = finalHeight;
                    }
                }
            }
            updateAllPreviews();
        });

        globalOutputFormatSelect.addEventListener('change', () => {
            globalSettings.outputFormat = globalOutputFormatSelect.value;
            // When user explicitly selects an output format, it implies they don't want to keep original type for export
            globalSettings.keepOriginalType = false;
            keepOriginalTypeCheckbox.checked = false;
            globalOutputFormatSelect.disabled = false; // Ensure it's enabled
        });

        // New event listener for the "Keep Original File Type" checkbox
        keepOriginalTypeCheckbox.addEventListener('change', () => {
            globalSettings.keepOriginalType = keepOriginalTypeCheckbox.checked;
            // If "Keep Original Type" is checked, disable and reset output format dropdown
            globalOutputFormatSelect.disabled = globalSettings.keepOriginalType;
            if (globalSettings.keepOriginalType) {
                // Optional: set globalOutputFormatSelect value to match first image type or a neutral default
                // For now, it just gets disabled, its value is ignored for exportZipBtn
            }
        });

        // Event listener for the new "Disable Image Previews" checkbox
        disablePreviewsCheckbox.addEventListener('change', () => {
            globalSettings.displayPreviews = !disablePreviewsCheckbox.checked; // Invert logic: checked means NO previews
            imageGrid.innerHTML = ''; // Clear current previews
            // Re-process existing files based on new preview setting
            const currentFiles = Array.from(imageStates.values()).map(state => state.file);
            if (currentFiles.length > 0) {
                // Clear existing states and re-handle files to apply new preview setting
                imageStates.clear();
                handleFiles(currentFiles); // This will re-trigger the loading bar and card creation
            }
        });


        // Global Convert All & Download Button (Unchanged behavior for now - only processes images)
        convertAllBtn.addEventListener('click', async () => {
            if (imageStates.size === 0) {
                showGeneralMessage('Please load at least one file to convert.', 'error');
                return;
            }

            showGeneralMessage('Starting conversion of all images...', 'info');
            let conversionCount = 0;

            for (const [cardId, fileState] of imageStates.entries()) {
                const { file, originalImage, relativePath, isImage } = fileState;
                const { invertColors, saturation, enableScaling, scaleWidth, scaleHeight, maintainAspectRatio, outputFormat } = globalSettings;

                if (!isImage) {
                    showGeneralMessage(`Skipping direct download for non-image file "${relativePath || file.name}". Only images can be converted and downloaded individually.`, 'info');
                    continue; // Skip non-image files for this button
                }
                if (!originalImage) {
                     showGeneralMessage(`Skipping image "${relativePath || file.name}" for direct download as its preview failed to load.`, 'error');
                     continue;
                }

                let finalWidth = originalImage.width;
                let finalHeight = originalImage.height;

                // Scaling logic
                if (enableScaling) {
                    let inputWidth = parseInt(scaleWidth);
                    let inputHeight = parseInt(scaleHeight);

                    const isValidWidth = !isNaN(inputWidth) && inputWidth > 0;
                    const isValidHeight = !isNaN(inputHeight) && inputHeight > 0;

                    const originalAspectRatio = originalImage.width / originalImage.height;

                    if (maintainAspectRatio) {
                        if (isValidWidth && !isValidHeight) {
                            finalWidth = inputWidth;
                            finalHeight = Math.round(inputWidth / originalAspectRatio);
                        } else if (!isValidWidth && isValidHeight) {
                            finalHeight = inputHeight;
                            finalWidth = Math.round(inputHeight * originalAspectRatio);
                        } else if (isValidWidth && isValidHeight) {
                            const ratioW = inputWidth / originalImage.width;
                            const ratioH = inputHeight / originalImage.height;
                            const ratio = Math.min(ratioW, ratioH);
                            finalWidth = Math.round(originalImage.width * ratio);
                            finalHeight = Math.round(originalImage.height * ratio);
                        } else {
                            finalWidth = originalImage.width;
                            finalHeight = originalImage.height;
                        }
                    } else {
                        if (isValidWidth) {
                            finalWidth = inputWidth;
                        }
                        if (isValidHeight) {
                            finalHeight = inputHeight;
                        }
                    }
                }

                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = finalWidth;
                offscreenCanvas.height = finalHeight;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                let filterString = '';
                if (invertColors) {
                    filterString += 'invert(100%) ';
                }
                filterString += `saturate(${saturation}%)`;
                offscreenCtx.filter = filterString.trim();

                offscreenCtx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

                let outputExtension = '';
                let skipCanvasDownload = false;
                switch (outputFormat) {
                    case 'image/png': outputExtension = 'png'; break;
                    case 'image/jpeg': outputExtension = 'jpg'; break;
                    case 'image/webp': outputExtension = 'webp'; break;
                    case 'image/avif': outputExtension = 'avif'; skipCanvasDownload = true; break; // Browser doesn't natively support toDataURL/toBlob for AVIF
                    case 'image/tiff': outputExtension = 'tiff'; skipCanvasDownload = true; break; // Browser doesn't natively support toDataURL/toBlob for TIFF
                    default: outputExtension = 'dat'; skipCanvasDownload = true;
                }

                // For direct download, we just use the new file name (flattened path)
                const fileNameWithoutExtension = file.name.split('.').slice(0, -1).join('.');
                const downloadFileName = `${fileNameWithoutExtension}_converted.${outputExtension}`;


                if (!skipCanvasDownload) {
                    const quality = 1.0;
                    try {
                        const imageDataURL = offscreenCanvas.toDataURL(outputFormat, quality);
                        const a = document.createElement('a');
                        a.href = imageDataURL;
                        a.download = downloadFileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);

                        conversionCount++;
                    } catch (e) {
                        showGeneralMessage(`Error converting "${relativePath || file.name}": ${e.message}.`, 'error');
                    }
                } else {
                     showGeneralMessage(
                        `Conversion for "${relativePath || file.name}" to ${outputExtension.toUpperCase()} is not natively supported by the browser for direct download. Skipping.`,
                        'error'
                    );
                }
            }
            if (conversionCount > 0) {
                showGeneralMessage(`Successfully converted and downloaded ${conversionCount} image(s).`, 'info');
            } else {
                showGeneralMessage('No images were successfully converted or downloaded.', 'error');
            }
        });

        // Export All Files as Zip Button (Updated with Keep Original File Type logic for images and direct inclusion for non-images)
        exportZipBtn.addEventListener('click', async () => {
            if (imageStates.size === 0) {
                showGeneralMessage('Please load at least one file to export.', 'error');
                return;
            }

            showGeneralMessage('Preparing files for ZIP export...', 'info');
            const zip = new JSZip();
            let processedCount = 0; // Track successfully processed files for the ZIP

            const blobPromises = [];

            for (const [cardId, fileState] of imageStates.entries()) {
                const { file, originalImage, relativePath, isImage } = fileState;
                const { invertColors, saturation, enableScaling, scaleWidth, scaleHeight, maintainAspectRatio, outputFormat, keepOriginalType } = globalSettings;

                // Determine the path and name for the file inside the ZIP
                let zipFilePath;
                const originalFileNameWithExt = file.name; // Keep original full name for splitting

                if (!isImage || !originalImage || (isImage && !globalSettings.displayPreviews && !keepOriginalType)) {
                    // This block handles:
                    // 1. Non-image files
                    // 2. Image files where `originalImage` failed to load (e.g., corrupted, unsupported browser render)
                    // 3. Image files where `displayPreviews` is false AND `keepOriginalType` is false
                    //    In this case, if we didn't load the `originalImage` due to previews being disabled,
                    //    we can't apply adjustments/conversion, so we just add the original file.
                    zipFilePath = relativePath && relativePath.length > 0 ? relativePath : originalFileNameWithExt;
                    blobPromises.push(new Promise(resolve => {
                        zip.file(zipFilePath, file);
                        processedCount++;
                        // More specific message based on condition
                        if (!isImage) {
                            showGeneralMessage(`Added "${zipFilePath}" to ZIP (non-image, original file).`, 'info');
                        } else if (!originalImage) {
                            showGeneralMessage(`Added "${zipFilePath}" to ZIP (image preview failed, original file).`, 'info');
                        } else if (!globalSettings.displayPreviews) {
                             showGeneralMessage(`Added "${zipFilePath}" to ZIP (image, previews disabled, original file).`, 'info');
                        }
                        resolve();
                    }));
                    continue; // Skip image-specific processing for this file
                }

                // --- Image Processing Logic (only for valid images where originalImage is loaded) ---
                let targetMimeType;
                let targetExtension;
                let skipCanvasProcessing = false; // Flag for AVIF/TIFF or other non-canvas supported outputs

                if (keepOriginalType) {
                    targetMimeType = file.type;
                    switch (file.type) {
                        case 'image/png': targetExtension = 'png'; break;
                        case 'image/jpeg': targetExtension = 'jpg'; break; // Normalize .jpeg to .jpg
                        case 'image/webp': targetExtension = 'webp'; break;
                        case 'image/avif': targetExtension = 'avif'; skipCanvasProcessing = true; break; // Directly add original blob if original is AVIF
                        case 'image/tiff': targetExtension = 'tiff'; skipCanvasProcessing = true; break; // Directly add original blob if original is TIFF
                        default: targetMimeType = 'image/png'; targetExtension = 'png'; // Fallback for unknown original image types (should ideally not happen with previous type check)
                    }
                } else {
                    targetMimeType = outputFormat;
                    switch (outputFormat) {
                        case 'image/png': targetExtension = 'png'; break;
                        case 'image/jpeg': targetExtension = 'jpg'; break;
                        case 'image/webp': targetExtension = 'webp'; break;
                        case 'image/avif': targetExtension = 'avif'; skipCanvasProcessing = true; break; // Canvas won't support it for output
                        case 'image/tiff': targetExtension = 'tiff'; skipCanvasProcessing = true; break; // Canvas won't support it for output
                        default: targetMimeType = 'image/png'; targetExtension = 'png'; break;
                    }
                }

                // If canvas processing is skipped for an image (e.g., AVIF/TIFF, or chosen output not supported by canvas)
                if (skipCanvasProcessing) {
                    zipFilePath = relativePath && relativePath.length > 0 ? relativePath : originalFileNameWithExt;
                    // If it was supposed to be converted but couldn't be by canvas
                    if (!keepOriginalType) {
                        const parts = (relativePath || originalFileNameWithExt).split('/');
                        const namePart = parts.pop().split('.').slice(0, -1).join('.');
                        parts.push(`${namePart}_converted.${targetExtension}`);
                        zipFilePath = parts.join('/');
                        showGeneralMessage(`Original image "${relativePath || file.name}" added directly to ZIP as "${zipFilePath}" (adjustments skipped, conversion to chosen format not supported).`, 'info');
                    } else { // original type was unsupported and kept
                        showGeneralMessage(`Original image "${relativePath || file.name}" added directly to ZIP (adjustments skipped for unsupported original type).`, 'info');
                    }

                    blobPromises.push(new Promise(resolve => {
                        zip.file(zipFilePath, file); // Add original file blob directly
                        processedCount++;
                        resolve();
                    }));
                    continue; // Skip canvas processing for this image
                }

                // --- Canvas Image Processing ---
                let finalWidth = originalImage.width;
                let finalHeight = originalImage.height;

                // Scaling logic (same as before)
                if (enableScaling) {
                    let inputWidth = parseInt(scaleWidth);
                    let inputHeight = parseInt(scaleHeight);

                    const isValidWidth = !isNaN(inputWidth) && inputWidth > 0;
                    const isValidHeight = !isNaN(inputHeight) && inputHeight > 0;

                    const originalAspectRatio = originalImage.width / originalImage.height;

                    if (maintainAspectRatio) {
                        if (isValidWidth && !isValidHeight) {
                            finalWidth = inputWidth;
                            finalHeight = Math.round(inputWidth / originalAspectRatio);
                        } else if (!isValidWidth && isValidHeight) {
                            finalHeight = inputHeight;
                            finalWidth = Math.round(inputHeight * originalAspectRatio);
                        } else if (isValidWidth && isValidHeight) {
                            const ratioW = inputWidth / originalImage.width;
                            const ratioH = inputHeight / originalImage.height;
                            const ratio = Math.min(ratioW, ratioH);
                            finalWidth = Math.round(originalImage.width * ratio);
                            finalHeight = Math.round(originalImage.height * ratio);
                        } else {
                            finalWidth = originalImage.width;
                            finalHeight = originalImage.height;
                        }
                    } else {
                        if (isValidWidth) {
                            finalWidth = inputWidth;
                        }
                        if (isValidHeight) {
                            finalHeight = inputHeight;
                        }
                    }
                }

                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = finalWidth;
                offscreenCanvas.height = finalHeight;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                let filterString = '';
                if (invertColors) {
                    filterString += 'invert(100%) ';
                }
                filterString += `saturate(${saturation}%)`;
                offscreenCtx.filter = filterString.trim();

                offscreenCtx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

                // Determine the ZIP file path and name for canvas-processed images
                if (keepOriginalType) {
                    // Keep original name/path, but ensure extension matches what toBlob creates (e.g., .jpeg -> .jpg)
                    const parts = (relativePath || originalFileNameWithExt).split('/');
                    const namePart = parts.pop().split('.').slice(0, -1).join('.');
                    parts.push(`${namePart}.${targetExtension}`);
                    zipFilePath = parts.join('/');
                } else {
                    // Add "_converted" suffix and use the chosen output format
                    const parts = (relativePath || originalFileNameWithExt).split('/');
                    const namePart = parts.pop().split('.').slice(0, -1).join('.');
                    parts.push(`${namePart}_converted.${targetExtension}`);
                    zipFilePath = parts.join('/');
                }

                // Create a promise for each blob conversion (for canvas-processed images)
                blobPromises.push(new Promise((resolve, reject) => {
                    offscreenCanvas.toBlob(function(blob) {
                        if (blob) {
                            zip.file(zipFilePath, blob);
                            processedCount++;
                            resolve();
                        } else {
                            showGeneralMessage(`Failed to create blob for "${relativePath || file.name}".`, 'error');
                            reject(new Error(`Failed to create blob for ${relativePath || file.name}`));
                        }
                    }, targetMimeType, 1.0); // Use 1.0 quality for best result
                }));
            }

            Promise.all(blobPromises)
                .then(() => {
                    if (processedCount > 0) {
                        zip.generateAsync({ type: "blob" })
                            .then(function(content) {
                                saveAs(content, "exported_files.zip"); // Changed zip name to be more general
                                showGeneralMessage(`Successfully exported ${processedCount} file(s) to "exported_files.zip".`, 'info');
                            })
                            .catch(function(error) {
                                showGeneralMessage(`Error creating ZIP file: ${error.message}.`, 'error');
                            });
                    } else {
                        showGeneralMessage('No files were successfully added to the ZIP.', 'error');
                    }
                })
                .catch(error => {
                    showGeneralMessage(`An error occurred during file processing for ZIP: ${error.message}`, 'error');
                });
        });


        // Drag and Drop Event Listeners
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('dragover');
            e.dataTransfer.dropEffect = 'copy';
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        // Click to Upload functionality
        dropZone.addEventListener('click', () => {
            hiddenFileInput.click();
        });

        hiddenFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(e.target.files);
                e.target.value = ''; // Clear the input so same file can be selected again
            }
        });
    </script>
</body>
</html>